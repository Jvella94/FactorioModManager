# Single workflow: read version, build for all targets, create release and upload assets
name: Tag, Build and Release


on:
  push:
    branches:
      - master


permissions:
  contents: write
  packages: write


jobs:
  set-version:
    name: Read version and set tag
    runs-on: ubuntu-latest
    outputs:
      tag: ${{ steps.read_version.outputs.tag }}
      version: ${{ steps.read_version.outputs.version }}
      prerelease: ${{ steps.read_version.outputs.prerelease }}
      icon_path: ${{ steps.read_version.outputs.icon_path }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4


      - name: Install xmllint
        run: sudo apt-get update && sudo apt-get install -y libxml2-utils


      - name: Read version and icon from csproj
        id: read_version
        run: |
          version=$(xmllint --xpath "string(//Project/PropertyGroup/Version)" UI/FactorioModManager.csproj)
          if [ -z "$version" ]; then
            echo "No <Version> found in csproj" >&2
            exit 1
          fi
          
          # Read ApplicationIcon path
          icon_path=$(xmllint --xpath "string(//Project/PropertyGroup/ApplicationIcon)" UI/FactorioModManager.csproj)
          if [ -z "$icon_path" ]; then
            echo "Warning: No <ApplicationIcon> found in csproj" >&2
            icon_path=""
          fi
          
          # construct tag like v1.2.3 or v1.2.3-beta.1
          tag="v$version"
          echo "version=$version" >> $GITHUB_OUTPUT
          echo "tag=$tag" >> $GITHUB_OUTPUT
          echo "icon_path=$icon_path" >> $GITHUB_OUTPUT


          # determine prerelease from semver prerelease part or common identifiers
          if echo "$version" | grep -qE '[-](alpha|beta|rc|dev|preview|pre|[A-Za-z])'; then
            echo "prerelease=true" >> $GITHUB_OUTPUT
          else
            echo "prerelease=false" >> $GITHUB_OUTPUT
          fi


  build:
    name: Build and package
    needs: set-version
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        include:
          - os: ubuntu-latest
            platform: linux-x64
            artifact_name: FactorioModManager-linux-x64
          - os: windows-latest
            platform: win-x64
            artifact_name: FactorioModManager-win-x64
          - os: macos-latest
            platform: osx-x64
            artifact_name: FactorioModManager-osx-x64
          - os: macos-latest
            platform: osx-arm64
            artifact_name: FactorioModManager-osx-arm64


    steps:
      - name: Checkout code
        uses: actions/checkout@v4


      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '9.0.x'


      - name: Restore dependencies
        run: dotnet restore


      - name: Publish
        run: |
          dotnet publish UI/FactorioModManager.csproj \
            --configuration Release \
            --runtime ${{ matrix.platform }} \
            --self-contained true \
            -p:PublishSingleFile=true \
            -p:UseAppHost=true \
            --output ./publish/${{ matrix.platform }}
        shell: bash


      - name: Create macOS .app bundle
        if: startsWith(matrix.platform, 'osx-')
        run: |
          APP_NAME="FactorioModManager"
          PLATFORM="${{ matrix.platform }}"
          VERSION="${{ needs.set-version.outputs.version }}"
          ICON_PATH="${{ needs.set-version.outputs.icon_path }}"
          PUBLISH_DIR="./publish/${PLATFORM}"
          APP_BUNDLE="${PUBLISH_DIR}/${APP_NAME}.app"
          
          # Create .app structure
          mkdir -p "${APP_BUNDLE}/Contents/MacOS"
          mkdir -p "${APP_BUNDLE}/Contents/Resources"
          
          # Move executable into bundle
          mv "${PUBLISH_DIR}/${APP_NAME}" "${APP_BUNDLE}/Contents/MacOS/"
          chmod +x "${APP_BUNDLE}/Contents/MacOS/${APP_NAME}"
          
          # Convert and copy icon if it exists
          if [ -n "$ICON_PATH" ] && [ -f "UI/$ICON_PATH" ]; then
            echo "Converting icon from UI/$ICON_PATH"
            
            # Create temporary iconset directory
            ICONSET_DIR="${APP_BUNDLE}/Contents/Resources/AppIcon.iconset"
            mkdir -p "$ICONSET_DIR"
            
            # Generate multiple sizes from the source icon using sips
            # macOS sips can read .ico and .png
            for size in 16 32 128 256 512; do
              sips -z $size $size "UI/$ICON_PATH" --out "${ICONSET_DIR}/icon_${size}x${size}.png" 2>/dev/null || true
              # Also create @2x versions
              size2x=$((size * 2))
              sips -z $size2x $size2x "UI/$ICON_PATH" --out "${ICONSET_DIR}/icon_${size}x${size}@2x.png" 2>/dev/null || true
            done
            
            # Convert iconset to icns
            iconutil -c icns "$ICONSET_DIR" -o "${APP_BUNDLE}/Contents/Resources/AppIcon.icns"
            
            # Clean up iconset
            rm -rf "$ICONSET_DIR"
            
            echo "Icon converted successfully"
          else
            echo "No icon found at UI/$ICON_PATH, skipping icon conversion"
          fi
          
          # Create Info.plist with version
          cat > "${APP_BUNDLE}/Contents/Info.plist" << EOF
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
            <key>CFBundleName</key>
            <string>${APP_NAME}</string>
            <key>CFBundleDisplayName</key>
            <string>Factorio Mod Manager</string>
            <key>CFBundleIdentifier</key>
            <string>com.yourname.factoriomodmanager</string>
            <key>CFBundleVersion</key>
            <string>${VERSION}</string>
            <key>CFBundleShortVersionString</key>
            <string>${VERSION}</string>
            <key>CFBundlePackageType</key>
            <string>APPL</string>
            <key>CFBundleExecutable</key>
            <string>${APP_NAME}</string>
            <key>CFBundleIconFile</key>
            <string>AppIcon</string>
            <key>LSMinimumSystemVersion</key>
            <string>10.15</string>
            <key>NSHighResolutionCapable</key>
            <true/>
          </dict>
          </plist>
          EOF
          
          # Remove loose executable and other files from publish root (keep only .app)
          find "${PUBLISH_DIR}" -maxdepth 1 -type f -delete
          find "${PUBLISH_DIR}" -maxdepth 1 -type d ! -name "${APP_NAME}.app" ! -path "${PUBLISH_DIR}" -exec rm -rf {} +
        shell: bash


      - name: Create archive (Linux/macOS)
        if: runner.os != 'Windows'
        run: |
          cd publish/${{ matrix.platform }}
          tar -czf ../../${{ matrix.artifact_name }}.tar.gz ./*


      - name: Create archive (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          cd publish/${{ matrix.platform }}
          Compress-Archive -Path * -DestinationPath ../../${{ matrix.artifact_name }}.zip


      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.artifact_name }}
          path: |
            ${{ matrix.artifact_name }}.tar.gz
            ${{ matrix.artifact_name }}.zip
          if-no-files-found: ignore


  release:
    name: Create GitHub Release
    needs: [set-version, build]
    runs-on: ubuntu-latest
    steps:
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts


      - name: Determine release metadata
        id: release_type
        run: |
          TAG="${{ needs.set-version.outputs.tag }}"
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "prerelease=${{ needs.set-version.outputs.prerelease }}" >> $GITHUB_OUTPUT


      - name: Create Release and upload assets
        uses: softprops/action-gh-release@v2
        with:
          name: Release ${{ steps.release_type.outputs.tag }}
          tag_name: ${{ steps.release_type.outputs.tag }}
          prerelease: ${{ steps.release_type.outputs.prerelease }}
          draft: false
          generate_release_notes: true
          files: |
            artifacts/**/*.tar.gz
            artifacts/**/*.zip
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
